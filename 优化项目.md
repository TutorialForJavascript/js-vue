# 优化项目

本部分是对vue.js基础用法的优化补完,对应代码在[optimization分支](https://github.com/TutorialForJavascript/hero-tutorial/tree/optimization).

我们的英雄手册项目已经能满足所有功能了,但交互体验上还有一些瑕疵.我们可以利用一些小技巧和html5的一些技术掩盖这些缺陷提高交互体验.

本文也是这部分的最后一篇文章,接下来我们会进入PWA应用阶段,进一步将我们的网页改造成PWA应用.

## App.vue细节优化

功能决定一个产品能不能进入市场,细节决定了一个产品在市场上的生存状况.网页的细节很多时候就体现在交互的连贯性上.

这部分主要就是在交互的连贯性上做文章.

### router切换点击优化

我们的router组件可以工作,但很容易出现点击后没有反应的情况,这是因为我们为了演示如何用`vue-router`将`router-view`放在了`el-menu-item`内部,我们必须点到这个标签才会跳转.
实际上`el-menu`已经实现了和`router-view`的继承,只需要将`el-menu`的`router`属性点亮并且将`el-menu-item`的`index`改为路由的路径,即可.

```html
<template>
  ...
            <el-menu class="el-menu-demo" mode="horizontal" router, default-active="/">
              <el-menu-item index="/">仪表盘</el-menu-item>
              <el-menu-item index="/herolist">英雄列表</el-menu-item>
              <el-menu-item index="/herodetail">创建英雄</el-menu-item>
            </el-menu>
  ...
</template>
```
这样修改后点击行为就可以得到优化了.

另一个瑕疵是当我们选中某个路径后刷新,页面会刷新--导航栏会回到初始状态,但`router-view`中的内容不会改变.这就会很奇怪了,一个比较简单的方式是利用html5的`sessionStorage`将当前的页面路由缓存下来.`sessionStorage`只对浏览器当前页面有效,多开多个浏览器页面不会相互影响,并且它会在页面关闭时删除,这就非常适合现在这个场景了.

我们需要定义一个`memu.js`的vuex对象.它用于管理这个缓存.

```js
const state = {
    current_index: "/"
}


// getters
const getters = {

}

// actions 定义业务逻辑
const actions = {
    changeCurrrentIndex: function (context, payload) {
        sessionStorage.setItem("current_index", payload.current_index)
    },
    loadCurrrentIndex: function (context) {
        let current_index = sessionStorage.getItem("current_index")
        if (current_index) {
            console.log(`load index from storage: ${current_index}`)
            let payload = { current_index }
            context.commit('changeCurrrentIndex', payload)
        } else {
            console.log("no index in storage")
        }
    }
}

// mutations 定义数据状态的操作
const mutations = {
    changeCurrrentIndex(state, payload) {
        let current_index = payload.current_index
        state.current_index = current_index
        console.log(`load current_index ${current_index}`)
    }
}

export default {
    namespaced: true,
    state,
    getters,
    actions,
    mutations
}
```

可以看到其中定义了两个方法:

+ `changeCurrrentIndex`当页面跳转到index对应路径时调用,用于缓存页面数据,这个可以通过为`el-menu`的`select`事件绑定回调函数实现
+ `loadCurrrentIndex`app节点创建时调用,将缓存下来的index信息加载到`current_index`

### router切换过渡效果

目前我们点击导航切换view比较生硬,我们可以通过vue自带的[过渡动画](https://cn.vuejs.org/v2/guide/transitions.html)标签`transition`来为`router-view`部分的加载提供过渡效果.

`transition`实际上我们还是使用的css的过渡效果定义.因此我们需要定义css部分.

最终我们的`App.vue`修改为了:

```vue
<template>
  <div id="app">
    <el-container>
      <el-header height="120">
        <header>
          <el-row :gutter="10" type="flex" justify="center">
            <h1>英雄指南</h1>
          </el-row>
          <el-row :gutter="10" type="flex" justify="center">
            <el-menu
              :default-active="activeIndex"
              class="el-menu-demo"
              mode="horizontal"
              router
              @select="changeIndex"
            >
              <el-menu-item index="/">仪表盘</el-menu-item>
              <el-menu-item index="/herolist">英雄列表</el-menu-item>
              <el-menu-item index="/herodetail">创建英雄</el-menu-item>
            </el-menu>
          </el-row>
          <el-divider></el-divider>
        </header>
      </el-header>
      <el-main>
        <transition name="slide" mode="out-in" appear>
          <router-view></router-view>
        </transition>
      </el-main>
    </el-container>
  </div>
</template>

<script>
export default {
  name: "app",
  data() {
    return {
      activeIndex: "/"
    };
  },
  methods: {
    changeIndex: function(index, indexPath) {
      console.log(index);
      this.$store.dispatch("menu/changeCurrrentIndex", {
        current_index: index
      });
    }
  },
  created: function() {
    this.$store.dispatch("menu/loadCurrrentIndex");
    this.$store.dispatch("herolist/syncHeros");
    console.log(`app create ${this.$store.state.menu.current_index}`);
    this.activeIndex = this.$store.state.menu.current_index;
  }
};
</script>

<style>
#app {
  font-family: "Avenir", Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
.slide-enter-active,
.slide-leave-active {
  transition: opacity 0.5s;
}
.slide-enter, .slide-leave-to /* .fade-leave-active below version 2.1.8 */ {
  opacity: 0;
}
</style>
```

## detail.vue细节优化

detai.vue组件是我们主要用于和用户交互的组件,其他更多的是展示,这块也是最需要优化的部分.
由于有表单要填而表单实际上是最容易体验差的部分,想象下有很多机构的官方网站,你要申请一个什么东西,他们就会给你一个表单让你填.
然后悲剧的是如果中途你有事就退出去了或者因为网络问题死活提交不上去,下次回来你就得从头再填一遍,往往这种表单还特别长,这就会体验很差甚至还不如去线下处理.

另一个点是处理网络连接.我们无法保证网络的稳定性和可用性,这是网络自身的特点.因此像详情页这样需要现从网络上获取数据的页面就会很不好处理,用户需要知道页面是否准备好了.
因此我们就需要有一个加载动画来告诉用户页面有没准备好.

### 等待加载动画

element提供了[Loading](https://element.eleme.cn/#/zh-CN/component/loading)模块可以用于提供一个等待画面.
这个模块提供一个vue指令`v-loading`用于掩盖组件和其子组件,并提供了修饰符来定义掩盖的范围和特点.它支持的修饰符有:

参数|说明|类型|可选值|默认值
---|---|---|---|---
target|需要覆盖的DOM节点.可传入一个DOM对象或字符串;若传入字符串则会将其作为参数传入document.querySelector以获取到对应DOM节点.|object/string|---|document.body
body|以使遮罩插入至DOM中的`body`上|boolean|---|false
fullscreen|全屏遮罩|boolean|---|true
lock|锁定屏幕的滚动|boolean|---|false

而其值必须是一个布尔值,`true`表示显示加载动画,否则不展示

我们使用它默认的转圈圈样式简单展示下.

```vue
<template>
  <div class="herodetail" v-loading="show">
    ...
  </div>
</template>
<script>
...

export default {
  n...
  computed: {
    show: function() {
      if (this.id && !this.hero.name) {
        return true;
      } else {
        return false;
      }
    },
  }
  ...
}
</script>
```

### 缓存已经生成但未提交的英雄

我们希望生成英雄的缓存是无感的,那我们就需要启动一个监听器来一直监听`hero`对象的变化情况然后根据其变化情况做缓存,而在组件创建时(即利用钩子`created`)我们需要根据是否有`id`来判别是不是创建页.也就可以判别需不需要加载缓存的已生成未提交的英雄.这个页面中我们没有将这个存储逻辑放在vuex中处理,
是因为这个业务的缓存数据怎么也不会有别的组件需要知道.而App.vue中则有可能会有一些子组件需要知道当前所在的index信息.
最终我们的`herodetail.vue`这样:

```vue
<template>
  <div class="herodetail" v-loading="show">
    <el-row type="flex" justify="center">
      <h1>英雄详情</h1>
    </el-row>
    <el-row type="flex" justify="center">
      <el-col :span="6">
        <el-card shadow="hover" v-if="id">
          <template v-slot:header>
            <div class="clearfix">
              <span>{{ hero.id }}</span>
            </div>
          </template>
          <div>
            名字：
            <el-input v-model="hero.name" :placeholder="hero.name"></el-input>
            <el-button type="primary" round @click="submitHero">提交</el-button>
            <el-button type="primary" round @click="goBack">后退</el-button>
          </div>
        </el-card>
        <el-card shadow="hover" v-else>
          名字：
          <el-input v-model="hero.name" placeholder="请输入英雄的名字"></el-input>
          <el-button type="primary" round @click="randomHeroQuality">随机生成</el-button>
          <el-button type="primary" round @click="submitHero" v-if="has_quality && hero.name">提交</el-button>
        </el-card>
      </el-col>
      <el-col :span="12" v-if="has_quality">
        <h4>英雄属性</h4>
        <ve-radar :data="chartData" :after-config="afterconfig"></ve-radar>
      </el-col>
    </el-row>
  </div>
</template>
<script>
import { mapActions } from "vuex";
import { random100 } from "../utils";

export default {
  name: "herodetail",
  data: function() {
    return {
      hero: {
        name: "",
        quality: {}
      }
    };
  },
  props: {
    id: {
      type: String,
      default: null
    }
  },
  computed: {
    show: function() {
      if (this.id && !this.hero.name) {
        return true;
      } else {
        return false;
      }
    },
    has_quality: function() {
      if (Object.keys(this.hero.quality).length !== 0) {
        return true;
      } else {
        return false;
      }
    },
    chartData: function() {
      let data = {
        columns: ["name", ...Object.keys(this.hero.quality)],
        rows: [{ name: this.hero.name, ...this.hero.quality }]
      };
      return data;
    }
  },
  methods: {
    ...mapActions("herolist", ["appendHero", "updateHero"]),
    afterconfig: function(option) {
      option.radar.indicator.forEach(i => (i.max = 100));
      return option;
    },
    submitHero: function() {
      if (this.id) {
        let hero = { ...this.hero };
        this.updateHero({ heroId: Number(this.id), source: hero });
        this.hero = Object.assign(this.hero, hero);
      } else {
        let hero = { ...this.hero };
        this.appendHero({ heroObj: hero });
        this.hero.name = "";
        this.hero.quality = {};
      }
    },
    randomHeroQuality: function() {
      this.hero.quality = {
        速度: random100(),
        成长性: random100(),
        持久力: random100(),
        破坏力: random100(),
        精密度: random100(),
        射程距离: random100()
      };
    },
    setCreatedHero: function(newVal, oldValVal) {
      if (newVal.name !== "" || Object.keys(newVal.quality).length !== 0) {
        if (this.id) {
        } else {
          sessionStorage.setItem("created_hero", JSON.stringify(newVal));
        }
      }
    },
    goBack: function() {
      window.history.length > 1 ? this.$router.go(-1) : this.$router.push("/");
    }
  },
  watch: {
    id: function(newVal, oldVal) {
      if (newVal === null) {
        this.hero = {
          name: "",
          quality: {}
        };
      }
    },
    hero: {
      handler: "setCreatedHero",
      deep: true,
      immediate: true
    }
  },
  created: function() {
    if (this.id) {
      let heroId = Number(this.id);
      this.createdPromise = this.$axios.get(`/hero/${heroId}`);
    } else {
      let created_hero = sessionStorage.getItem("created_hero");
      if (created_hero){
        this.hero = JSON.parse(created_hero);
      } else {
      }
    }
  },

  mounted: async function() {
    if (this.id) {
      let heroId = Number(this.id);
      let response = await this.createdPromise;
      this.hero = response.data.result;
    }
  }
};
</script>
```

## 利用sse优化数据流

另外两个页面其实都是拿我们向服务器请求来的英雄列表信息进行的展示.他们都会使用钩子`created`在每次进入页面时拉取更新这个数据.
这确实可以在大多数情况下满足需求,但其实并不好--每次拉取的都是当时的全量数据,在数据量很大数据增量很大的情况下就很难满足需求了.有什么办法呢?

当然我们可以使用websocket,但这就需要服务端大改,并不能平顺的迁移,而我们只是要一个轻量级的推送功能而已.这种时候就可以使用[sse]()技术了.